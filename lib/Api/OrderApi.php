<?php
/**
 * OrderApi
 * PHP version 5
 *
 * @category Class
 * @package  ChannelEngine\ApiClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ChannelEngine API V2
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.4.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ChannelEngine\ApiClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use ChannelEngine\ApiClient\ApiException;
use ChannelEngine\ApiClient\Configuration;
use ChannelEngine\ApiClient\HeaderSelector;
use ChannelEngine\ApiClient\ObjectSerializer;

/**
 * OrderApi Class Doc Comment
 *
 * @category Class
 * @package  ChannelEngine\ApiClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class OrderApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation orderAcknowledge
     *
     * Merchant: Acknowledge Order
     *
     * @param  \ChannelEngine\ApiClient\Model\OrderAcknowledgement $model Relations between the id&#39;s returned by ChannelEngine and the references which the merchant uses (required)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChannelEngine\ApiClient\Model\ApiResponse
     */
    public function orderAcknowledge($model)
    {
        list($response) = $this->orderAcknowledgeWithHttpInfo($model);
        return $response;
    }

    /**
     * Operation orderAcknowledgeWithHttpInfo
     *
     * Merchant: Acknowledge Order
     *
     * @param  \ChannelEngine\ApiClient\Model\OrderAcknowledgement $model Relations between the id&#39;s returned by ChannelEngine and the references which the merchant uses (required)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChannelEngine\ApiClient\Model\ApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderAcknowledgeWithHttpInfo($model)
    {
        $returnType = '\ChannelEngine\ApiClient\Model\ApiResponse';
        $request = $this->orderAcknowledgeRequest($model);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderAcknowledgeAsync
     *
     * Merchant: Acknowledge Order
     *
     * @param  \ChannelEngine\ApiClient\Model\OrderAcknowledgement $model Relations between the id&#39;s returned by ChannelEngine and the references which the merchant uses (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderAcknowledgeAsync($model)
    {
        return $this->orderAcknowledgeAsyncWithHttpInfo($model)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderAcknowledgeAsyncWithHttpInfo
     *
     * Merchant: Acknowledge Order
     *
     * @param  \ChannelEngine\ApiClient\Model\OrderAcknowledgement $model Relations between the id&#39;s returned by ChannelEngine and the references which the merchant uses (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderAcknowledgeAsyncWithHttpInfo($model)
    {
        $returnType = '\ChannelEngine\ApiClient\Model\ApiResponse';
        $request = $this->orderAcknowledgeRequest($model);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderAcknowledge'
     *
     * @param  \ChannelEngine\ApiClient\Model\OrderAcknowledgement $model Relations between the id&#39;s returned by ChannelEngine and the references which the merchant uses (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orderAcknowledgeRequest($model)
    {
        // verify the required parameter 'model' is set
        if ($model === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling orderAcknowledge'
            );
        }

        $resourcePath = '/v2/orders/acknowledge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($model)) {
            $_tempBody = $model;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderCreate
     *
     * Channel: Create Order
     *
     * @param  \ChannelEngine\ApiClient\Model\ChannelOrderRequest $model  (required)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChannelEngine\ApiClient\Model\ApiResponse
     */
    public function orderCreate($model)
    {
        list($response) = $this->orderCreateWithHttpInfo($model);
        return $response;
    }

    /**
     * Operation orderCreateWithHttpInfo
     *
     * Channel: Create Order
     *
     * @param  \ChannelEngine\ApiClient\Model\ChannelOrderRequest $model  (required)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChannelEngine\ApiClient\Model\ApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderCreateWithHttpInfo($model)
    {
        $returnType = '\ChannelEngine\ApiClient\Model\ApiResponse';
        $request = $this->orderCreateRequest($model);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderCreateAsync
     *
     * Channel: Create Order
     *
     * @param  \ChannelEngine\ApiClient\Model\ChannelOrderRequest $model  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderCreateAsync($model)
    {
        return $this->orderCreateAsyncWithHttpInfo($model)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderCreateAsyncWithHttpInfo
     *
     * Channel: Create Order
     *
     * @param  \ChannelEngine\ApiClient\Model\ChannelOrderRequest $model  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderCreateAsyncWithHttpInfo($model)
    {
        $returnType = '\ChannelEngine\ApiClient\Model\ApiResponse';
        $request = $this->orderCreateRequest($model);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderCreate'
     *
     * @param  \ChannelEngine\ApiClient\Model\ChannelOrderRequest $model  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orderCreateRequest($model)
    {
        // verify the required parameter 'model' is set
        if ($model === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling orderCreate'
            );
        }

        $resourcePath = '/v2/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($model)) {
            $_tempBody = $model;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderGetByFilter
     *
     * Merchant: Get Orders By Filter
     *
     * @param  string[] $filterStatuses filterStatuses (optional)
     * @param  string[] $filterMerchantOrderNos filterMerchantOrderNos (optional)
     * @param  bool $filterExcludeMarketplaceFulfilledOrdersAndLines filterExcludeMarketplaceFulfilledOrdersAndLines (optional)
     * @param  string $filterFulfillmentType Filter orders on fulfillment type. This will include all orders lines, even if they are partially fulfilled by the marketplace.  To exclude orders and lines that are fulfilled by the marketplace from the response, set ExcludeMarketplaceFulfilledOrdersAndLines to true. (optional)
     * @param  int $filterPage filterPage (optional)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse
     */
    public function orderGetByFilter($filterStatuses = null, $filterMerchantOrderNos = null, $filterExcludeMarketplaceFulfilledOrdersAndLines = null, $filterFulfillmentType = null, $filterPage = null)
    {
        list($response) = $this->orderGetByFilterWithHttpInfo($filterStatuses, $filterMerchantOrderNos, $filterExcludeMarketplaceFulfilledOrdersAndLines, $filterFulfillmentType, $filterPage);
        return $response;
    }

    /**
     * Operation orderGetByFilterWithHttpInfo
     *
     * Merchant: Get Orders By Filter
     *
     * @param  string[] $filterStatuses (optional)
     * @param  string[] $filterMerchantOrderNos (optional)
     * @param  bool $filterExcludeMarketplaceFulfilledOrdersAndLines (optional)
     * @param  string $filterFulfillmentType Filter orders on fulfillment type. This will include all orders lines, even if they are partially fulfilled by the marketplace.  To exclude orders and lines that are fulfilled by the marketplace from the response, set ExcludeMarketplaceFulfilledOrdersAndLines to true. (optional)
     * @param  int $filterPage (optional)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderGetByFilterWithHttpInfo($filterStatuses = null, $filterMerchantOrderNos = null, $filterExcludeMarketplaceFulfilledOrdersAndLines = null, $filterFulfillmentType = null, $filterPage = null)
    {
        $returnType = '\ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse';
        $request = $this->orderGetByFilterRequest($filterStatuses, $filterMerchantOrderNos, $filterExcludeMarketplaceFulfilledOrdersAndLines, $filterFulfillmentType, $filterPage);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderGetByFilterAsync
     *
     * Merchant: Get Orders By Filter
     *
     * @param  string[] $filterStatuses (optional)
     * @param  string[] $filterMerchantOrderNos (optional)
     * @param  bool $filterExcludeMarketplaceFulfilledOrdersAndLines (optional)
     * @param  string $filterFulfillmentType Filter orders on fulfillment type. This will include all orders lines, even if they are partially fulfilled by the marketplace.  To exclude orders and lines that are fulfilled by the marketplace from the response, set ExcludeMarketplaceFulfilledOrdersAndLines to true. (optional)
     * @param  int $filterPage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderGetByFilterAsync($filterStatuses = null, $filterMerchantOrderNos = null, $filterExcludeMarketplaceFulfilledOrdersAndLines = null, $filterFulfillmentType = null, $filterPage = null)
    {
        return $this->orderGetByFilterAsyncWithHttpInfo($filterStatuses, $filterMerchantOrderNos, $filterExcludeMarketplaceFulfilledOrdersAndLines, $filterFulfillmentType, $filterPage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderGetByFilterAsyncWithHttpInfo
     *
     * Merchant: Get Orders By Filter
     *
     * @param  string[] $filterStatuses (optional)
     * @param  string[] $filterMerchantOrderNos (optional)
     * @param  bool $filterExcludeMarketplaceFulfilledOrdersAndLines (optional)
     * @param  string $filterFulfillmentType Filter orders on fulfillment type. This will include all orders lines, even if they are partially fulfilled by the marketplace.  To exclude orders and lines that are fulfilled by the marketplace from the response, set ExcludeMarketplaceFulfilledOrdersAndLines to true. (optional)
     * @param  int $filterPage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderGetByFilterAsyncWithHttpInfo($filterStatuses = null, $filterMerchantOrderNos = null, $filterExcludeMarketplaceFulfilledOrdersAndLines = null, $filterFulfillmentType = null, $filterPage = null)
    {
        $returnType = '\ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse';
        $request = $this->orderGetByFilterRequest($filterStatuses, $filterMerchantOrderNos, $filterExcludeMarketplaceFulfilledOrdersAndLines, $filterFulfillmentType, $filterPage);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderGetByFilter'
     *
     * @param  string[] $filterStatuses (optional)
     * @param  string[] $filterMerchantOrderNos (optional)
     * @param  bool $filterExcludeMarketplaceFulfilledOrdersAndLines (optional)
     * @param  string $filterFulfillmentType Filter orders on fulfillment type. This will include all orders lines, even if they are partially fulfilled by the marketplace.  To exclude orders and lines that are fulfilled by the marketplace from the response, set ExcludeMarketplaceFulfilledOrdersAndLines to true. (optional)
     * @param  int $filterPage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orderGetByFilterRequest($filterStatuses = null, $filterMerchantOrderNos = null, $filterExcludeMarketplaceFulfilledOrdersAndLines = null, $filterFulfillmentType = null, $filterPage = null)
    {

        $resourcePath = '/v2/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($filterStatuses)) {
            $filterStatuses = ObjectSerializer::serializeCollection($filterStatuses, 'multi', true);
        }
        if ($filterStatuses !== null) {
            $queryParams['filter.statuses'] = ObjectSerializer::toQueryValue($filterStatuses);
        }
        // query params
        if (is_array($filterMerchantOrderNos)) {
            $filterMerchantOrderNos = ObjectSerializer::serializeCollection($filterMerchantOrderNos, 'multi', true);
        }
        if ($filterMerchantOrderNos !== null) {
            $queryParams['filter.merchantOrderNos'] = ObjectSerializer::toQueryValue($filterMerchantOrderNos);
        }
        // query params
        if ($filterExcludeMarketplaceFulfilledOrdersAndLines !== null) {
            $queryParams['filter.excludeMarketplaceFulfilledOrdersAndLines'] = ObjectSerializer::toQueryValue($filterExcludeMarketplaceFulfilledOrdersAndLines);
        }
        // query params
        if ($filterFulfillmentType !== null) {
            $queryParams['filter.fulfillmentType'] = ObjectSerializer::toQueryValue($filterFulfillmentType);
        }
        // query params
        if ($filterPage !== null) {
            $queryParams['filter.page'] = ObjectSerializer::toQueryValue($filterPage);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderGetNew
     *
     * Merchant: Get New Orders
     *
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse
     */
    public function orderGetNew()
    {
        list($response) = $this->orderGetNewWithHttpInfo();
        return $response;
    }

    /**
     * Operation orderGetNewWithHttpInfo
     *
     * Merchant: Get New Orders
     *
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderGetNewWithHttpInfo()
    {
        $returnType = '\ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse';
        $request = $this->orderGetNewRequest();

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderGetNewAsync
     *
     * Merchant: Get New Orders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderGetNewAsync()
    {
        return $this->orderGetNewAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderGetNewAsyncWithHttpInfo
     *
     * Merchant: Get New Orders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderGetNewAsyncWithHttpInfo()
    {
        $returnType = '\ChannelEngine\ApiClient\Model\CollectionOfMerchantOrderResponse';
        $request = $this->orderGetNewRequest();

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderGetNew'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orderGetNewRequest()
    {

        $resourcePath = '/v2/orders/new';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderInvoice
     *
     * Merchant: Download Invoice
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function orderInvoice($merchantOrderNo, $useCustomerCulture = null)
    {
        list($response) = $this->orderInvoiceWithHttpInfo($merchantOrderNo, $useCustomerCulture);
        return $response;
    }

    /**
     * Operation orderInvoiceWithHttpInfo
     *
     * Merchant: Download Invoice
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderInvoiceWithHttpInfo($merchantOrderNo, $useCustomerCulture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->orderInvoiceRequest($merchantOrderNo, $useCustomerCulture);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderInvoiceAsync
     *
     * Merchant: Download Invoice
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderInvoiceAsync($merchantOrderNo, $useCustomerCulture = null)
    {
        return $this->orderInvoiceAsyncWithHttpInfo($merchantOrderNo, $useCustomerCulture)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderInvoiceAsyncWithHttpInfo
     *
     * Merchant: Download Invoice
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderInvoiceAsyncWithHttpInfo($merchantOrderNo, $useCustomerCulture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->orderInvoiceRequest($merchantOrderNo, $useCustomerCulture);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderInvoice'
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orderInvoiceRequest($merchantOrderNo, $useCustomerCulture = null)
    {
        // verify the required parameter 'merchantOrderNo' is set
        if ($merchantOrderNo === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchantOrderNo when calling orderInvoice'
            );
        }

        $resourcePath = '/v2/orders/{merchantOrderNo}/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($useCustomerCulture !== null) {
            $queryParams['useCustomerCulture'] = ObjectSerializer::toQueryValue($useCustomerCulture);
        }

        // path params
        if ($merchantOrderNo !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantOrderNo' . '}',
                ObjectSerializer::toPathValue($merchantOrderNo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderPackingSlip
     *
     * Merchant: Download Packing Slip
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function orderPackingSlip($merchantOrderNo, $useCustomerCulture = null)
    {
        list($response) = $this->orderPackingSlipWithHttpInfo($merchantOrderNo, $useCustomerCulture);
        return $response;
    }

    /**
     * Operation orderPackingSlipWithHttpInfo
     *
     * Merchant: Download Packing Slip
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \ChannelEngine\ApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function orderPackingSlipWithHttpInfo($merchantOrderNo, $useCustomerCulture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->orderPackingSlipRequest($merchantOrderNo, $useCustomerCulture);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChannelEngine\ApiClient\Model\ApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orderPackingSlipAsync
     *
     * Merchant: Download Packing Slip
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderPackingSlipAsync($merchantOrderNo, $useCustomerCulture = null)
    {
        return $this->orderPackingSlipAsyncWithHttpInfo($merchantOrderNo, $useCustomerCulture)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orderPackingSlipAsyncWithHttpInfo
     *
     * Merchant: Download Packing Slip
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orderPackingSlipAsyncWithHttpInfo($merchantOrderNo, $useCustomerCulture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->orderPackingSlipRequest($merchantOrderNo, $useCustomerCulture);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orderPackingSlip'
     *
     * @param  string $merchantOrderNo The unique order reference as used by the merchant (required)
     * @param  bool $useCustomerCulture Generate the invoice in the billing address&#39; country&#39;s language (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orderPackingSlipRequest($merchantOrderNo, $useCustomerCulture = null)
    {
        // verify the required parameter 'merchantOrderNo' is set
        if ($merchantOrderNo === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchantOrderNo when calling orderPackingSlip'
            );
        }

        $resourcePath = '/v2/orders/{merchantOrderNo}/packingslip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($useCustomerCulture !== null) {
            $queryParams['useCustomerCulture'] = ObjectSerializer::toQueryValue($useCustomerCulture);
        }

        // path params
        if ($merchantOrderNo !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantOrderNo' . '}',
                ObjectSerializer::toPathValue($merchantOrderNo),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

}
